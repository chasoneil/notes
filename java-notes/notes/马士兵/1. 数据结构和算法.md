##  数据结构和算法



### 一、基本概念

#### 1.1. 算法优劣的核心指标

* 时间复杂度

* 额外空间复杂度

  是指除了任务要求的，为了实现任务目标而额外开辟的空间

* 常数项时间



要搞明白上面几个指标，我们需要先了解以下几个概念：

> 常数时间操作

如果说一个操作每次执行的时间都是固定的，比如数组的寻址， 自增这样的操作，那么这种操作我们称为常数时间的操作

常见的常数时间操作：

```
算术运算 （+ - * / %）
常见的位运算 （>> >>> << | & ^）
赋值 比较 自增 自减等操作
数组寻址操作
```



> 如何确定算法流程时间复杂度

1. 想象该算法流程所处理的数据状况，要按照最差的来
2. 把整个流程彻底拆分为一个个的基本动作，保证每个动作都是常数时间的操作
3. 如果数据量为N， 看看基本动作的数量和N是什么关系
4. 化简表达式之后，取复杂级别最高的那一个 记为O（最高级别复杂度）



#### 1.2 排序LOWB三人组

> 选择排序



> 冒泡排序



> 插入排序



#### 1.3 什么是一个好的算法

优先考虑时间复杂度，在时间复杂度完全相同的情况下，考虑额外空间复杂度，一般不考察常数项时间



#### 1.4 算法的分类

* 知道怎么算的算法

  绝大多数算法都是先把怎么算这个逻辑理清楚，然后再写算法，这些算法都属于知道怎么算的算法

* 知道怎么试的算法



#### 1.5 认识对数器

* 你想要测方法a
* 实现一个复杂度不好但是容易实现并且保证对的方法b
* 实现一个随机样本产生器，自己实现就可以自己控制样本
* 把方法a和方法b跑相同的随机样本，看看得到的结果是不是一样
* 如果有一个不一样，打印样本进行人工干预
* 当样本数量足够多的时候，ab都一样，可以确定方法a已经正确



#### 1.6 二分法

二分法能做什么：

* 在一个有序数组中，找某个数是否存在   code04
* 在一个有序数组中，找 >= 某个数最左侧的位置
* 在一个有序数组中，找 <= 某个数最右侧的位置
* 局部最小值问题


#### 1.7 异或运算

相同为0 ，不同为1   <异或运算就记为无进位相加>

*主要是区分，有个同或运算，规则和异或刚好相反*

异或运算能做什么：

* 0 ^ N  = N
* N ^ N =  0
* 异或运算满足交换律和结合律



### 二、基本数据结构

#### 1. 栈 和 队列

> 使用双向链表实现栈和队列

### 三、高级排序算法

#### 1.归并排序
#### 2.快速排序

Partition 过程:

Q1:
给定一个数组arr和一个整数num, 要求把小于num的数放到数组的左边，把大于num的数放到数组的右边。左右两边不要求排序
要求空间复杂度 O(1) 时间复杂度 O(N)

思路: 给定一个小于num的区，我们称为min区，最开始的时候，这个区里面没有任何元素，这个区从数组头开始
指针i从数组头开始，如果当前指针的数小于num，那么将min区右边的第一个元素和当前这个数交换，min区向右扩展 i++;
当指针指向的数 > num, 直接跳下一个 i++
eg:
[2,4,3,5,4,3,6,1] num = 3;

-> min) [2P,4,3,5,4,3,6,1]  第一步有个min i指向数组的第一个元素
-> min [2),4P,3,5,4,3,6,1]  2比3小，那么将2和min区右边第一个元素交换，发现第一个元素就是他自己，不用交换 i++ min区后移 
-> min [2),4,3P,5,4,3,6,1]  4 > 3, 直接 i++
-> min [2,3),4,5P,4,3,6,1]  3 = 3, 将3 和4(min区右边的第一个元素) 交换 min右扩， i++
-> min [2,3),4,5,4P,3,6,1]  5 > 3, i++
-> min [2,3),4,5,4,3P,6,1]  4 > 3, i++
-> min [2,3,3),5,4,4,6P,1]  3 = 3, 交换,右扩,i++
-> min [2,3,3),5,4,4,6,1P]  6 > 3, i++
-> min [2,3,3,1),4,4,6,5P]  1 < 3, 交换,右扩,i++ 越界，结束
[2,3,3,1,4,4,6,5]

Code03_TargetLeftRight

Q2: 
对上面的问题进行升级, 给定一个数 target，要求 < target 在左边 = target在中间 > target在右边
(荷兰国旗问题)

思路和上面一样
有个min区最开始在-1, 有个max区最开始在越界的位置 arr.length
有个指针i 从头开始
如果 arr[i] < target, 将这个数和 min外面第一个数交换 min 右扩 i++
如果 arr[i] = target, 执行 i++
如果 arr[i] > target, 将这个数和max左侧第一个数交换， max左扩，i不变！

Code04_DutchFlag


#### 四、二叉树

##### 1、什么叫二叉树?

二叉树就是一种数据结构，内部存放一个数据，通过两个指针分别指向左右两侧的数据结构

* 二叉树不能有环状结构
* 二叉树不能有多于两个节点的子数


##### 2、二叉树的先序，中序，后序遍历

* 先序  任何子树的处理顺序都是先头节点，再左子树，然后右子树   （头左右）
* 中序  任何子树的处理顺序都是先左子树，再头节点，然后右子树   （左头右）
* 后序  任何子数的处理顺序都是先左子树，再右子树，然后头节点   （左右头）

> 什么是子树?

从某个节点出发，包含这个节点以及下面所有节点的才叫子树

> 使用递归的方式 进行二叉树的先序 中序 后序打印

leetcode.tree.traversal._递归_遍历二叉树_

> 使用非递归的方式 进行二叉树的先序 中序 后序的打印

leetcode.tree.traversal._非递归_遍历二叉树_

> 后序遍历的高级

leetcode.tree.traversal._高级_非递归_遍历二叉树_

##### 3、二叉树的深度优先遍历

所谓深度优先遍历，其实就是按层进行遍历

比如一个二叉树
```
     1
   2   3
 4  5 6  7
```     

 
 那么他深度优先遍历的顺序就是 1 2 3 4 5 6 7
 先第一层，再第二层，再第三层
 
 > 统计二叉树的最大宽度
 
 leetcode.tree._二叉树的最大宽度_
 
##### 4、二叉树的序列化和反序列化

所谓序列化： 二叉树本身这种结构是一种内存结构，通过left right指针指定的一种结构，那么要将这种结构
保存到文件中，需要将其序列化。

所谓反序列化： 和上面的定义刚好相反，我们将文件中的结构最终读取生成到内存中的二叉树结构，这就是反序列化

可以用先序 中序 后序遍历进行序列化

怎么进行序列化的，就怎么进行反序列化

leetcode.tree._递归_二叉树的序列化_

> 二叉树按层进行序列化

leetcode.tree._非递归_二叉树按层进行序列化_
