## 数据结构和算法



### 一、基本概念

#### 1. 算法优劣的核心指标

* 时间复杂度

* 额外空间复杂度

  是指除了任务要求的，为了实现任务目标而额外开辟的空间

* 常数项时间



要搞明白上面几个指标，我们需要先了解以下几个概念：



> 常数时间操作

如果说一个操作每次执行的时间都是固定的，比如数组的寻址， 自增这样的操作，那么这种操作我们称为常数时间的操作

常见的常数时间操作：

* 算术运算 （+ - * / %）
* 常见的位运算 （>> >>> << | & ^）
* 赋值 比较 自增 自减等操作
* 数组寻址操作



> 如何确定算法流程时间复杂度

1. 想象该算法流程所处理的数据状况，要按照最差的来

2. 把整个流程彻底拆分为一个个的基本动作，保证每个动作都是常数时间的操作

3. 如果数据量为N， 看看基本动作的数量和N是什么关系

4. 化简表达式之后，取复杂级别最高的那一个 记为O（最高级别复杂度）

   

#### 2. 排序LOWB三人组

> 选择排序

sort.low.Code01_SelectSort

> 冒泡排序

sort.low.Code01_BubbleSort

> 插入排序

sort.low.Code01_InsertSort



#### 3. 什么是一个好的算法

优先考虑时间复杂度，在时间复杂度完全相同的情况下，考虑额外空间复杂度，一般不考察常数项时间



#### 4. 算法的分类

* 知道怎么算的算法

  绝大多数算法都是先把怎么算这个逻辑理清楚，然后再写算法，这些算法都属于知道怎么算的算法

* 知道怎么试的算法



#### 5. 认识对数器

* 你想要测方法a
* 实现一个复杂度不好但是容易实现并且保证对的方法b
* 实现一个随机样本产生器，自己实现就可以自己控制样本
* 把方法a和方法b跑相同的随机样本，看看得到的结果是不是一样
* 如果有一个不一样，打印样本进行人工干预
* 当样本数量足够多的时候，ab都一样，可以确定方法a已经正确
* 

#### 6. 二分法

二分法能做什么：

* 在一个有序数组中，找某个数是否存在 code04
* 在一个有序数组中，找 >= 某个数最左侧的位置
* 在一个有序数组中，找 <= 某个数最右侧的位置
* 局部最小值问题



#### 7. 异或运算

相同为0 ，不同为1 <异或运算就记为无进位相加>

*主要是区分，有个同或运算，规则和异或刚好相反*

异或运算能做什么：

* 0 ^ N = N
* N ^ N = 0
* 异或运算满足交换律和结合律



### 二、基本数据结构

#### 1. 栈和队列

> 使用双向链表实现栈和队列





### 三、高级排序算法

#### 1. 归并排序

#### 2. 快速排序

> Partition 过程:

Q1: 给定一个数组arr和一个整数num, 要求把小于num的数放到数组的左边，把大于num的数放到数组的右边。

左右两边不要求排序 要求空间复杂度 O(1) 时间复杂度 O(N)

==思路==: 给定一个小于num的区，我们称为min区，最开始的时候，这个区里面没有任何元素，这个区从数组头开始 指针i从数组头开始，

如果当前指针的数小于num，那么将min区右边的第一个元素和当前这个数交换，min区向右扩展 i++; 

当指针指向的数 > num, 直接跳下一个 i++ 

**eg: [2,4,3,5,4,3,6,1]  num = 3;**

-> min) [2P,4,3,5,4,3,6,1] 第一步有个min i指向数组的第一个元素

 -> min [2),4P,3,5,4,3,6,1] 2比3小，那么将2和min区右边第一个元素交换，发现第一个元素就是他自己，不用交换 i++ min区后移 

-> min [2),4,3P,5,4,3,6,1] 4 > 3, 直接 i++ 

-> min [2,3),4,5P,4,3,6,1] 3 = 3, 将3 和4(min区右边的第一个元素) 交换 min右扩， i++ 

-> min [2,3),4,5,4P,3,6,1] 5 > 3, i++ -> min [2,3),4,5,4,3P,6,1] 4 > 3, i++

-> min [2,3,3),5,4,4,6P,1] 3 = 3, 交换,右扩,i++ 

-> min [2,3,3),5,4,4,6,1P] 6 > 3, i++ 

-> min [2,3,3,1),4,4,6,5P] 1 < 3, 交换,右扩,i++ 越界，

结束 [2,3,3,1,4,4,6,5]



sort.Code03_TargetLeftRight



Q2: 对上面的问题进行升级, 给定一个数 target，要求 < target 在左边 = target在中间 > target在右边 (荷兰国旗问题)

思路和上面一样 有个min区最开始在-1, 有个max区最开始在越界的位置 arr.length 有个指针i 从头开始 如果 arr[i] < target, 将这个数和 min外面第一个数交换 min 右扩 i++ 如果 arr[i] = target, 执行 i++ 如果 arr[i] > target, 将这个数和max左侧第一个数交换， max左扩，i不变！

Code04_DutchFlag



> 快速排序的思路和代码

根据上面的问题，我们非常轻易的就得出了一个结论：

荷兰国旗问题，当我们完成了一轮荷兰国旗的时候，作为target的数已经在其排序后该有的位置：

* 这个数的左边都是比他小的 排序后也是
* 这个数的右边都是比他大的 排序后也是

那么我们就认为这个数已经排序好了



假设我们玩一轮荷兰国旗，将数组分成了左右两边，那么再使用递归，继续在左右两边玩儿荷兰国旗问题

最终实现排序



> 快排的优劣





#### 3. 比较器与堆

> 什么是完全二叉树？

完全二叉树就是从左往右，从上往下，要么是满的二叉树，要么是正在变满的状态。 啥叫正在变满的状态呢？

* 就是如果不是满树，那么一定是左边是满的，右边是不满的

比如

```
  1 
2
```

这是一个完全二叉树

```
  1
    2
```

这就不是一个完全二叉树



##### 1. 堆

堆其实就是一个完全二叉树，但不仅仅是一个完全二叉树

> 大根堆和小根堆

* 当完全二叉树的每一颗子树最大值都是他的头节点的值，他就是一个大根堆

* 与之相反， 任何一颗子树的最小值都是他的头节点的值，那么他就是一个小根堆 

* 但是，不管是大根堆还是小根堆，首先他都必须是一颗完全二叉树

  

> 堆排序的 Partition1

给定一个数组，从 L - R 上构建一个完全二叉树，那么构建的完全二叉树分两种，一种是小根堆，一种是大根堆

Q1: 给定一个数组，将他组织成一个大根堆

sort.heap.Code01_ArrayToHeap push()

Q2: 给定一个大根堆，将最大的数弹出，还要保证原来的结构是大根堆

sort.heap.Code01_ArrayToHeap pop()



> 堆排序

1. 先让整个数组都变成大根堆结构
2. 把堆的最大值和堆的末尾进行交换，然后减少堆的长度，继续调整堆
3. 堆的大小减成0后，排序完成

综合时间复杂度 O(N * logN) 综合空间复杂度 O(1) 优势



> Java中自己实现的堆结构

PriorityQueue



##### 2. 比较器

* 比较器的实质就是重载比较运算符
* 比较器可以很好的应用在特殊标准的排序上



##### 3. 前缀树

- 单个字符串中，字符从前到后的加到一棵多叉树上
- 前缀树节点本身不存储有效数据，节点本身有两个属性
  - pass    表示经过这个节点的数量
  - end     表示以这个节点为结束的数量
- 所有的样本都是这样田间，如果没有路就新建，如果有路就复用
- 沿途节点的pass加1，每个字符串结束时来到的节点end值 + 1



Q1: 创建一个前缀树的流程



> 前缀树可以干什么？

* 查询某个字符串在数组中出现了几次   end 次数
* 可以方便的查询以 XX 为前缀的字符串的次数 pass次数



#### 四、二叉树

##### 1、什么叫二叉树?

二叉树就是一种数据结构，内部存放一个数据，通过两个指针分别指向左右两侧的数据结构

* 二叉树不能有环状结构
* 二叉树不能有多于两个节点的子数

##### 2、二叉树的先序，中序，后序遍历

* 先序 任何子树的处理顺序都是先头节点，再左子树，然后右子树 （头左右）
* 中序 任何子树的处理顺序都是先左子树，再头节点，然后右子树 （左头右）
* 后序 任何子数的处理顺序都是先左子树，再右子树，然后头节点 （左右头）

> 什么是子树?

从某个节点出发，包含这个节点以及下面所有节点的才叫子树



> 使用递归的方式 进行二叉树的先序 中序 后序打印

leetcode.tree.traversal.*递归_遍历二叉树*



> 使用非递归的方式 进行二叉树的先序 中序 后序的打印

leetcode.tree.traversal.*非递归_遍历二叉树*



> 后序遍历的高级

leetcode.tree.traversal.*高级_非递归_遍历二叉树*



##### 3、二叉树的深度优先遍历

所谓深度优先遍历，其实就是按层进行遍历

比如一个二叉树

```
     1
   2   3
 4  5 6  7
```

那么他深度优先遍历的顺序就是 1 2 3 4 5 6 7 先第一层，再第二层，再第三层

> 统计二叉树的最大宽度

leetcode.tree.*二叉树的最大宽度*

##### 4、二叉树的序列化和反序列化

所谓序列化： 二叉树本身这种结构是一种内存结构，通过left right指针指定的一种结构，那么要将这种结构 保存到文件中，需要将其序列化。

所谓反序列化： 和上面的定义刚好相反，我们将文件中的结构最终读取生成到内存中的二叉树结构，这就是反序列化

可以用先序 中序 后序遍历进行序列化

怎么进行序列化的，就怎么进行反序列化

leetcode.tree.*递归_二叉树的序列化*

> 二叉树按层进行序列化

leetcode.tree.*非递归_二叉树按层进行序列化*

Q1:如何设计一个打印整棵树的打印函数？

按照一定的格式打印出数，没有的地方我们用空格补齐





Q2: 二叉树结构定义如下

```java
public class Node {
    public int val;
    public Node left;
    public Node right;
    public Node parent;
}
```

给你二叉树中的某个节点，返回该节点的后继节点。

后继节点： 一个二叉树中序遍历的时候，他的后一个节点就是他的后继节点

A1：

(1) 不管怎么样，既然他有父亲节点的指针，那我们肯定可以找到这个二叉树的root

(2) 找到root之后，开始使用中序遍历遍历二叉树，直接找到他的后继节点



A2：

（1）对于任意一个节点 x , 有右树的情况，那么他的后继节点一定是右树上的最左值

（2）对于任意一个节点 x，没有右树的情况，那么他就往上找，如果他是父节点的右树，那么继续往上

（3）继续第二步到找到某个节点是他父节点的左树，那么这个父节点就是他的后继节点





Q3: 请把一段纸条竖着放在桌子上，然后从纸条的下边向上方对折一次，压出折痕后展开。此时折痕是凹下去的

即折痕凸起的方向指向纸条的背面。如果从纸条的下边向上方连续对折两次，压出折痕后展开，此时有三条折痕，

从上到下依次是下折痕，下折痕和上折痕。

给定一个输入参数N，代表纸条都从下边向上方连续对折N次，请从上到下打印所有折痕方向。

例如 N=1 打印 down N =2 打印 down down up



A：

其实要求打印的就是一棵树的中序遍历， N表示树的层级



> 二叉树的递归套路

Q4: 使用递归的方法判断一颗二叉树是不是平衡二叉树？

啥叫平衡二叉树？ 一颗二叉树以及其子树，左右子树的最大高度差不能大于1，这种二叉树就叫平衡二叉树



A:

（1） 怎么判断一颗二叉树是不是平衡二叉树？ 对于任何一个节点 X, 要满足以下两点

（2） 满足 X 的左子树和右子树都必须是平衡二叉树   满足 X 左子树和右子树的最大高度不能大于1





Q5: 给定一颗二叉树的头节点 head, 任何两个节点之间都存在距离， 返回整颗二叉树的最大距离。

最大距离就是从节点A 到 节点 B 经过的节点数 比如 B是A的子节点或者父节点，那么最大距离就是 2 （统计经过的节点数）

对于任意节点 X

A:

（1）怎么求最大距离， 有两种情况

（2）最大距离不经过 X ,这种情况的最大距离，要么就是左子树的最大距离，要么就是右子树的最大距离，两颗树取大值

（3）最大距离经过X，这种情况是 经过X的左子树的最远距离到右子树的最远距离，两个距离和

（4）啥叫离自己最远的点呢？其实不就是二叉树的高度吗



Q6： 给定一个二叉树的头节点head， 返回这个二叉树中最大二叉搜索子树的头节点

搜索二叉树：整个树上没有重复值，左树值比root小， 右树都比root大，每个子树也都满足
